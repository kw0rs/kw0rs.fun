<!DOCTYPE html>
<html lang="ru">
<head>
  <!-- Head content remains the same -->
  <!-- ... -->
</head>
<body class="text-white font-sans" x-data="mediaApp()" x-init="loadItems()">
  <!-- Most of the body content remains the same -->
  <!-- ... -->

  <script>
    function mediaApp() {
      return {
        search: '',
        categoryFilter: '',
        sortKey: 'rating-desc',
        modalItem: null,
        items: [],
        loading: true,
        error: null,
        minRating: null,
        minYear: null,
        maxYear: null,
        imageObserver: null,
        showReview: true, // По умолчанию показываем рецензию, если она есть
        
        // New function to translate type values to display text
        getTypeDisplay(typeValue) {
          const typeMap = {
            'movie': 'Фильмы',
            'show': 'Сериалы',
            'anime': 'Аниме',
            'game': 'Игры',
            'book': 'Чтиво',
            'cartoon': 'Мультики'
          };
          return typeMap[typeValue] || typeValue;
        },

        async loadItems() {
          this.loading = true;
          this.error = null;
          const urls = ['anime_data.json', 'movies_data.json', 'games_data.json', 'books_data.json', 'cartoons_data.json'];
          let allItems = [];
          try {
            for (const url of urls) {
              const res = await fetch(url);
              if (!res.ok) throw new Error(`Ошибка загрузки ${url}`);
              const data = await res.json();
              if (!Array.isArray(data)) throw new Error(`Ожидался массив в ${url}`);
              allItems = allItems.concat(data);
            }
            this.items = allItems.map(i => {
              const r = parseFloat(i.rating);
              return {
                title: i.title || 'Без названия',
                type: i.type || 'Неизвестно',
                typeDisplay: this.getTypeDisplay(i.type) || 'Неизвестно', // Add the display value
                year: i.year || 'Н/Д',
                rating: !isNaN(r) ? r : null,
                genres: Array.isArray(i.genres) ? i.genres : [],
                description: i.description || '',
                review: i.review || '',
                image: i.image || null,
                imageLoaded: false // Флаг для отслеживания загрузки картинки
              };
            });
            
            // Инициализация Intersection Observer после загрузки данных
            this.$nextTick(() => {
              this.initLazyLoading();
            });
          } catch (e) {
            this.error = `Не удалось загрузить данные: ${e.message}`;
            this.items = [];
          } finally {
            this.loading = false;
          }
        },

        // Rest of the methods remain the same...
        initLazyLoading() {
          // ... existing code
        },

        openModal(item) { 
          this.modalItem = {...item};
          // По умолчанию показываем рецензию, если она есть, иначе показываем описание
          this.showReview = item.review ? true : false;
        },
        
        handleImageError(e, item) { 
          item.image = null; 
          item.imageLoaded = false;
        },

        pickRandomItem() {
          // ... existing code
        },

        getRatingText(item) {
          return (item.rating != null) ? item.rating : '?';
        },
        
        getRatingClass(item) {
          // ... existing code
        },
        
        getToggleButtonClass(type) {
          // ... existing code
        },
        
        get hasAnyContent() {
          return this.modalItem && (this.modalItem.review || this.modalItem.description);
        },

        get filteredItems() {
          return this.items
            .filter(i => !this.search || i.title.toLowerCase().includes(this.search.toLowerCase()))
            .filter(i => !this.categoryFilter || i.type === this.categoryFilter)
            .filter(i => this.minRating == null || (i.rating != null && i.rating >= this.minRating))
            .filter(i => this.minYear == null || (i.year !== 'Н/Д' && parseInt(i.year) >= this.minYear))
            .filter(i => this.maxYear == null || (i.year !== 'Н/Д' && parseInt(i.year) <= this.maxYear));
        },

        get filteredAndSortedItems() {
          // ... existing code
        }
      }
    }
  </script>
</body>
</html>
