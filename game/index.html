<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Сапёр — Hard (30×16, 99 mines)</title>
<style>
  :root{
    --bg:#0a0a0a;
    --panel:#1a1a1a;
    --muted:#888888;
    --border:#555555; /* сделал ярче */
    --accent-blue:#007AFF;
    --accent-gold:#FFD700;
    --accent-pink:#FF69B4;
    --text:#ffffff;
    --cell:#121212;
    --cell-alt:#1a1a1a;
    --flag-color:var(--accent-gold);
    --mine-color:#ff4d4f;
    --shadow: 0 6px 18px rgba(0,0,0,0.7);
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:var(--bg);
    color:var(--text);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px;
  }

  .wrap{
    width:100%;
    max-width:1200px;
    display:grid;
    grid-template-columns: 340px 1fr;
    gap:28px;
    align-items:start;
  }

  .panel{
    background:linear-gradient(180deg,var(--panel),#0f0f0f);
    border:1px solid var(--border);
    padding:20px;
    border-radius:14px;
    box-shadow:var(--shadow);
  }

  h1{font-size:18px;margin:0 0 12px}
  .sub{color:var(--muted);font-size:13px;margin-bottom:16px}

  .stats{
    display:flex;
    gap:12px;
    align-items:center;
    margin-bottom:14px;
  }
  .stat{
    background:rgba(255,255,255,0.02);
    padding:10px 12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.03);
    min-width:86px;
    text-align:center;
  }
  .stat .num{font-weight:700;font-size:18px}

  .board-wrap{
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    border-radius:14px;
    padding:18px;
    border:1px solid var(--border);
    box-shadow:var(--shadow);
    overflow:auto;
  }

  .board{
    display:inline-grid;
    touch-action: manipulation;
    user-select:none;
    -webkit-user-select:none;
    grid-template-columns: repeat(30, 28px);
    grid-auto-rows: 28px;
    gap: 1px; /* разделитель между клетками */
    background:#555555; /* яркая граница между клетками */
    border-radius: 10px;
  }

  .cell{
    width:28px;
    height:28px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:var(--cell);
    color:var(--text);
    font-weight:700;
    font-size:14px;
    border-radius:6px;
    cursor:pointer;
    box-shadow: inset 0 -2px 0 rgba(255,255,255,0.02);
    user-select:none;
  }
  .cell.alt{background:var(--cell-alt)}
  .cell.revealed{
    background:linear-gradient(180deg,#0b0b0b,#131313);
    color:var(--text);
    cursor:default;
    box-shadow:none;
  }
  .cell.mine{
    background:linear-gradient(180deg,#2a0b0b,#3a0b0b);
    color:var(--mine-color);
  }
  .cell.flag{color:var(--flag-color)}
  .cell.question{color:var(--muted);font-weight:600}

  /* number colors */
  .n1{color:#4aa3ff}
  .n2{color:#7ee787}
  .n3{color:#ff8b6b}
  .n4{color:#9b9bff}
  .n5{color:#ff7aa2}
  .n6{color:#00d7ff}
  .n7{color:#ffe27a}
  .n8{color:#d0d0d0}

  /* responsive */
  @media (max-width:980px){
    .wrap{grid-template-columns:1fr;max-width:980px}
    .panel{order:2}
  }

  .footer{margin-top:16px;font-size:12px;color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>Сложный сапёр — Hard (30×16, 99 мин)</h1>
      <div class="sub">ПК/моб — работает. Правый клик ставит флаг, long-press на мобиле.</div>
      <div class="stats">
        <div class="stat">
          <div style="font-size:12px;color:var(--muted)">Мины</div>
          <div id="mines-left" class="num">99</div>
        </div>
        <div class="stat">
          <div style="font-size:12px;color:var(--muted)">Время</div>
          <div id="timer" class="num">0.0</div>
        </div>
        <div class="stat">
          <div style="font-size:12px;color:var(--muted)">Лучший</div>
          <div id="best" class="num">—</div>
        </div>
      </div>
      <button id="btn-new" class="btn btn-blue" style="margin-top:12px; width:100%; padding:14px; font-weight:600; border-radius:12px; border:1px solid var(--accent-blue); background:var(--panel); color:var(--text); cursor:pointer; user-select:none;">
        Новая игра
      </button>
      <div class="footer">Нет читов и подсказок — сам думай, где мины.</div>
    </div>

    <div class="board-wrap panel" id="boardPanel">
      <div id="boardContainer"></div>
    </div>
  </div>

<script>
(() => {
  const COLS = 30;
  const ROWS = 16;
  const MINES = 99;

  const boardContainer = document.getElementById('boardContainer');
  const minesLeftEl = document.getElementById('mines-left');
  const timerEl = document.getElementById('timer');
  const bestEl = document.getElementById('best');
  const btnNew = document.getElementById('btn-new');

  let grid = [];
  let revealed = 0;
  let flags = 0;
  let started = false;
  let lost = false;
  let timer = null;
  let startTime = 0;
  const bestKey = 'ms_best_hard';

  function resetState(){
    grid = new Array(ROWS);
    for(let r=0;r<ROWS;r++){
      grid[r] = new Array(COLS).fill().map(() => ({
        mine:false,
        count:0,
        revealed:false,
        flagged:false,
        question:false
      }));
    }
    revealed = 0;
    flags = 0;
    started = false;
    lost = false;
    clearInterval(timer);
    timer = null;
    timerEl.textContent = '0.0';
    minesLeftEl.textContent = MINES;
    updateBest();
  }

  function updateBest(){
    const b = localStorage.getItem(bestKey);
    bestEl.textContent = b ? (Number(b)/1000).toFixed(1)+'s' : '—';
  }

  function placeMines(excludeR, excludeC){
    const forbidden = new Set();
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        const rr=excludeR+dr, cc=excludeC+dc;
        if(rr>=0 && rr<ROWS && cc>=0 && cc<COLS) forbidden.add(rr+','+cc);
      }
    }
    let placed=0;
    while(placed < MINES){
      const r=Math.floor(Math.random()*ROWS);
      const c=Math.floor(Math.random()*COLS);
      if(forbidden.has(r+','+c)) continue;
      if(!grid[r][c].mine){
        grid[r][c].mine = true;
        placed++;
      }
    }
    // counts
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        if(grid[r][c].mine) continue;
        let cnt=0;
        for(let dr=-1; dr<=1; dr++){
          for(let dc=-1; dc<=1; dc++){
            if(dr===0 && dc===0) continue;
            const rr=r+dr, cc=c+dc;
            if(rr>=0 && rr<ROWS && cc>=0 && cc<COLS && grid[rr][cc].mine) cnt++;
          }
        }
        grid[r][c].count=cnt;
      }
    }
  }

  function buildBoard(){
    boardContainer.innerHTML = '';
    const board = document.createElement('div');
    board.className = 'board';
    board.style.gridTemplateColumns = `repeat(${COLS}, 28px)`;
    board.style.gridAutoRows = '28px';
    board.style.gap = '1px';
    boardContainer.appendChild(board);

    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        const cell = document.createElement('div');
        cell.className = 'cell '+(((r+c)&1)?'alt':'');
        cell.dataset.r = r;
        cell.dataset.c = c;
        cell.dataset.index = r*COLS + c;
        cell.addEventListener('click', onClick);
        cell.addEventListener('contextmenu', onContextMenu);
        addTouchFlag(cell);
        board.appendChild(cell);
      }
    }
  }

  function addTouchFlag(el){
    let touchTimer=null;
    el.addEventListener('touchstart', (e)=>{
      touchTimer = setTimeout(()=>{
        toggleFlag({currentTarget: el, preventDefault: ()=>{}});
      }, 450);
    }, {passive:true});
    el.addEventListener('touchmove', ()=>{
      if(touchTimer){ clearTimeout(touchTimer); touchTimer=null; }
    }, {passive:true});
    el.addEventListener('touchend', ()=>{
      if(touchTimer){ clearTimeout(touchTimer); touchTimer=null; }
    }, {passive:true});
  }

  function onClick(e){
    if(lost) return;
    const el = e.currentTarget;
    const r = +el.dataset.r, c = +el.dataset.c;
    revealCell(r,c);
  }

  function onContextMenu(e){
    e.preventDefault();
    if(lost) return;
    toggleFlag(e);
  }

  function toggleFlag(e){
    const el = e.currentTarget;
    const r = +el.dataset.r, c = +el.dataset.c;
    const cell = grid[r][c];
    if(cell.revealed) return;
    if(cell.flagged){
      cell.flagged = false;
      cell.question = true;
      flags--;
    } else if(cell.question){
      cell.question = false;
    } else {
      cell.flagged = true;
      flags++;
    }
    renderCell(r,c);
    minesLeftEl.textContent = Math.max(0, MINES - flags);
  }

  function revealCell(r,c){
    if(lost) return;
    if(!started){
      placeMines(r,c);
      startTimer();
      started = true;
    }
    const cell = grid[r][c];
    if(cell.revealed || cell.flagged) return;
    if(cell.mine){
      cell.revealed = true;
      revealAllMines();
      gameOver(false);
      return;
    }
    floodReveal(r,c);
    checkWin();
  }

  function floodReveal(sr, sc){
    const stack=[[sr,sc]];
    while(stack.length){
      const [r,c]=stack.pop();
      const cell=grid[r][c];
      if(cell.revealed || cell.flagged) continue;
      cell.revealed=true;
      revealed++;
      renderCell(r,c);
      if(cell.count === 0){
        for(let dr=-1; dr<=1; dr++){
          for(let dc=-1; dc<=1; dc++){
            if(dr===0 && dc===0) continue;
            const rr=r+dr, cc=c+dc;
            if(rr>=0 && rr<ROWS && cc>=0 && cc<COLS){
              const neigh=grid[rr][cc];
              if(!neigh.revealed && !neigh.flagged) stack.push([rr,cc]);
            }
          }
        }
      }
    }
  }

  function revealAllMines(){
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        if(grid[r][c].mine){
          grid[r][c].revealed=true;
          renderCell(r,c);
        }
      }
    }
  }

  function checkWin(){
    const totalCells=ROWS*COLS;
    if(revealed === totalCells - MINES){
      gameOver(true);
    }
  }

  function gameOver(win){
    lost = !win;
    stopTimer();
    if(win){
      for(let r=0; r<ROWS; r++){
        for(let c=0; c<COLS; c++){
          if(grid[r][c].mine) grid[r][c].flagged = true;
          renderCell(r,c);
        }
      }
      const totalMs = Date.now() - startTime;
      saveBest(totalMs);
    }
  }

  function saveBest(ms){
    const prev=localStorage.getItem(bestKey);
    if(!prev || ms < Number(prev)){
      localStorage.setItem(bestKey,String(ms));
      updateBest();
    }
  }

  function startTimer(){
    startTime=Date.now();
    timerEl.textContent = '0.0';
    timer=setInterval(()=>{
      const ms=Date.now()-startTime;
      timerEl.textContent=(ms/1000).toFixed(1);
    },100);
  }
  function stopTimer(){
    if(timer) clearInterval(timer);
    timer=null;
  }

  function renderCell(r,c){
    const idx=r*COLS+c;
    const el=boardContainer.querySelector('.cell[data-index="'+idx+'"]');
    const s=grid[r][c];
    el.className='cell '+(((r+c)&1)?'alt':'');
    if(s.revealed){
      el.classList.add('revealed');
      el.classList.remove('flag','question');
      if(s.mine){
        el.classList.add('mine');
        el.innerHTML = '&#x1F4A3;';
        el.style.color = 'var(--mine-color)';
      } else if(s.count > 0){
        el.textContent = s.count;
        el.classList.add('n'+s.count);
      } else {
        el.textContent = '';
      }
    } else {
      el.textContent = s.flagged ? '⚑' : (s.question ? '?' : '');
      if(s.flagged){
        el.classList.add('flag');
      } else if(s.question){
        el.classList.add('question');
      }
    }
  }

  function renderAll(){
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        renderCell(r,c);
      }
    }
  }

  btnNew.onclick = ()=>{
    resetState();
    buildBoard();
    renderAll();
  };

  // защита от выделения
  boardContainer.addEventListener('selectstart', e=>e.preventDefault());

  // стартуем игру сразу
  resetState();
  buildBoard();
  renderAll();

  updateBest();

})();
</script>
</body>
</html>
